[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

# Ogerpon Cornestone "Stones have a rank"
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = "function Card:get_id()"
position = 'after'
match_indent = true
payload = '''
    local ogerpons_cornerstone = find_joker('ogerpon_cornerstone')
    if #ogerpons_cornerstone > 0 and self.ability.effect == 'Stone Card' then
        return SMODS.Ranks["maelmc_Ogerpon"].id
    end
'''

# Prevent Sun Stone from rolling Ogerpon rank
[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "functions/pokeutils.lua"]'
pattern = '''if v.suit == card.base.suit then
        table.insert(poss_ranks, v.value)
'''
position = 'at'
match_indent = true
payload = '''
if v.suit == card.base.suit then
    if not (v.value == "maelmc_Ogerpon") then
        table.insert(poss_ranks, v.value)
    end
'''

[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "functions/pokeutils.lua"]'
pattern = '''if _r == card.base.value then
    table.insert(poss_ranks, v)
    break
'''
position = 'at'
match_indent = true
payload = '''
if _r == card.base.value then
    if not (v == "maelmc_Ogerpon") then
        table.insert(poss_ranks, v)
        break
    end
'''

# Gym Challenge and 'Til Death Do Us Part applying perish to jokers created (mainly for jokers in shop and boosters as Gym Leader already applies to jokers possessed)
# Also the code for Perrin / Photographer 
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if card.ability.consumeable and not skip_materialize then card:start_materialize() end"
position = "after"
match_indent = true
payload = '''
if _type == 'Joker' then
    if G.GAME.modifiers.maelmc_gym_challenge and not (get_type(card) == G.GAME.maelmc_gym_leader_type) then card:set_perishable(true) end
    if G.GAME.modifiers.maelmc_perish_3 then card:set_perishable(true) end
    photographer_util(card)
end
'''

# More code for Photographer, to make it compatible with evolving pokemon
[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "functions/pokefunctions.lua"]'
pattern = '''G.P_CENTERS.e_poke_shiny.on_load(card)
    end
  end'''
position = "after"
match_indent = true
payload = '''
photographer_util(card)
'''

# Right-click on Photographer to see all PokÃ©mon taken in photo
[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "functions/pokefunctions.lua"]'
pattern = '''if cardname == "ruins_of_alph" then
    for k, v in pairs(card.ability.extra.forms) do
      local form = {key = "j_poke_unown", form = v}
      table.insert(keys, form)
    end
  end'''
position = "after"
match_indent = true
payload = '''
if cardname == "photographer" then
    for k, v in pairs(card.ability.extra.timeless_woods_found) do
        table.insert(keys, v)
    end
end
'''

# maelmc_ban_no_perish banishing non perish jokers
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if _ch.rules then"
position = "before"
match_indent = true
payload = "local no_perish = false"

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "for k, v in ipairs(_ch.rules.custom) do"
position = "after"
match_indent = true
payload = '''
    if v.id == 'maelmc_ban_no_perish' then
        no_perish = true
    end
'''

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "if _ch.restrictions then"
position = "after"
match_indent = true
payload = '''
    if no_perish then
        local to_add = {}
        for _, v in ipairs(G.P_CENTER_POOLS.Joker) do
            if not v.perishable_compat then
                if not table.contains(to_add, v.key) then
                    to_add[#to_add+1] = v.key
                end
            end
        end
        local banned = {}
        for _, v in ipairs(_ch.restrictions.banned_cards) do
            local curr = v["id"]
            banned[#banned+1] = curr
        end
        for _, v in ipairs(to_add) do
            if not table.contains(banned,v) then
                _ch.restrictions.banned_cards[#_ch.restrictions.banned_cards+1] = {id = v}
            end
        end
    end
'''

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "if challenge.restrictions then"
position = "after"
match_indent = true
payload = '''
    local no_perish = false
    if challenge.rules and challenge.rules.custom then
        for k, v in ipairs(challenge.rules.custom) do
            if v.id == 'maelmc_ban_no_perish' then 
                no_perish = true
                break
            end
        end
    end
    if no_perish then
        local to_add = {}
        for _, v in ipairs(G.P_CENTER_POOLS.Joker) do
            if not v.perishable_compat then
                if not table.contains(to_add, v.key) then
                    to_add[#to_add+1] = v.key
                end
            end
        end
        local banned = {}
        for _, v in ipairs(challenge.restrictions.banned_cards) do
            local curr = v["id"]
            banned[#banned+1] = curr
        end
        for _, v in ipairs(to_add) do
            if not table.contains(banned,v) then
                challenge.restrictions.banned_cards[#challenge.restrictions.banned_cards+1] = {id = v}
            end
        end
    end
'''

# call to remove and start_dissolve triggers Guzzlord

#[[patches]]
#[patches.pattern]
#target = '=[SMODS Pokermon "functions/pokefunctions.lua"]'
#pattern = '''remove = function(self, card, context, check_shiny)
#  if check_shiny and card.edition and card.edition.poke_shiny then
#    SMODS.change_booster_limit(-1)
#  end'''
#position = "after"
#match_indent = true
#payload = '''
#    if card.config and card.config.center and (self == card.config.center) then
#        local guzzlords = find_joker("guzzlord")
#        for _, v in ipairs(guzzlords) do
#            v.ability.extra.Xmult = v.ability.extra.Xmult + v.ability.extra.Xmult_mod
#            v:juice_up()
#            card_eval_status_text(v, 'extra', nil, nil, nil, {message = "Eaten", COLOUR = G.C.DARK_EDITION})
#        end
#    end
#'''

#[[patches]]
#[patches.pattern]
#target = 'card.lua'
#pattern = "function Card:start_dissolve(dissolve_colours, silent, dissolve_time_fac, no_juice)"
#position = "after"
#match_indent = true
#payload = '''
#    if not self.getting_sliced)
#'''

# Hazards giving hand size on Hazard Deck (copied from the original code of Hazard cards)
[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "enhancements/enhancement1.lua"]'
pattern = '''in_pool = function(self, args) return false end,'''
position = "after"
match_indent = true
payload = '''set_ability = function(self, card, initial, delay_sprites)
    if G.GAME.modifiers.hazard_deck then
      card.ability.card_limit = 1
    end
  end,'''

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''function Card:set_ability(center, initial, delay_sprites)'''
position = "after"
match_indent = true
payload = '''    if G.GAME.modifiers.hazard_deck and self.config.center_key == "m_poke_hazard" and self.ability.card_limit then
        self.ability.card_limit = 0
    end'''

# Guzzlord eats the reroll button
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''{n=G.UIT.R, config={align = "cm", minw = 2.8, minh = 1.6, r=0.15,colour = G.C.GREEN, button = 'reroll_shop', func = 'can_reroll', hover = true,shadow = true}, nodes = {
                          {n=G.UIT.R, config={align = "cm", padding = 0.07, focus_args = {button = 'x', orientation = 'cr'}, func = 'set_button_pip'}, nodes={
                            {n=G.UIT.R, config={align = "cm", maxw = 1.3}, nodes={
                              {n=G.UIT.T, config={text = localize('k_reroll'), scale = 0.4, colour = G.C.WHITE, shadow = true}},
                            }},
                            {n=G.UIT.R, config={align = "cm", maxw = 1.3, minw = 1}, nodes={
                              {n=G.UIT.T, config={text = localize('$'), scale = 0.7, colour = G.C.WHITE, shadow = true}},
                              {n=G.UIT.T, config={ref_table = G.GAME.current_round, ref_value = 'reroll_cost', scale = 0.75, colour = G.C.WHITE, shadow = true}},
                            }}
                          }}
                        }},
                      }},'''
position = 'at'
match_indent = true
payload = '''G.GAME.modifiers.guzzlord_eat_shop_reroll and {} or {n=G.UIT.R, config={align = "cm", minw = 2.8, minh = 1.6, r=0.15,colour = G.C.GREEN, button = 'reroll_shop', func = 'can_reroll', hover = true,shadow = true}, nodes = {
    {n=G.UIT.R, config={align = "cm", padding = 0.07, focus_args = {button = 'x', orientation = 'cr'}, func = 'set_button_pip'}, nodes={
    {n=G.UIT.R, config={align = "cm", maxw = 1.3}, nodes={
        {n=G.UIT.T, config={text = localize('k_reroll'), scale = 0.4, colour = G.C.WHITE, shadow = true}},
    }},
    {n=G.UIT.R, config={align = "cm", maxw = 1.3, minw = 1}, nodes={
        {n=G.UIT.T, config={text = localize('$'), scale = 0.7, colour = G.C.WHITE, shadow = true}},
        {n=G.UIT.T, config={ref_table = G.GAME.current_round, ref_value = 'reroll_cost', scale = 0.75, colour = G.C.WHITE, shadow = true}},
    }}
    }}
}},
}},'''

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.FUNCS.can_reroll = function(e)'''
position = "after"
payload = '''if G.GAME.modifiers.guzzlord_eat_shop_reroll then
        e.config.colour = G.C.BLACK
        e.config.button = nil
        return
    end'''
match_indent = true

# Guzzlord eats the shop sign
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''G.SHOP_SIGN = UIBox{
      definition = 
        {n=G.UIT.ROOT, config = {colour = G.C.DYN_UI.MAIN, emboss = 0.05, align = 'cm', r = 0.1, padding = 0.1}, nodes={
          {n=G.UIT.R, config={align = "cm", padding = 0.1, minw = 4.72, minh = 3.1, colour = G.C.DYN_UI.DARK, r = 0.1}, nodes={
            {n=G.UIT.R, config={align = "cm"}, nodes={
              {n=G.UIT.O, config={object = shop_sign}}
            }},
            {n=G.UIT.R, config={align = "cm"}, nodes={
              {n=G.UIT.O, config={object = DynaText({string = {localize('ph_improve_run')}, colours = {lighten(G.C.GOLD, 0.3)},shadow = true, rotate = true, float = true, bump = true, scale = 0.5, spacing = 1, pop_in = 1.5, maxw = 4.3})}}
            }},
          }},
        }},
      config = {
        align="cm",
        offset = {x=0,y=-15},
        major = G.HUD:get_UIE_by_ID('row_blind'),
        bond = 'Weak'
      }
    }'''
position = 'at'
match_indent = true
payload = '''G.SHOP_SIGN = UIBox{
      definition = 
        {n=G.UIT.ROOT, config = {colour = G.C.DYN_UI.MAIN, emboss = 0.05, align = 'cm', r = 0.1, padding = 0.1}, nodes={
          {n=G.UIT.R, config={align = "cm", padding = 0.1, minw = 4.72, minh = 3.1, colour = G.C.DYN_UI.DARK, r = 0.1}, nodes={
            G.GAME.modifiers.guzzlord_eat_shop_sign and {} or {n=G.UIT.R, config={align = "cm"}, nodes={
              {n=G.UIT.O, config={object = shop_sign}}
            }},
            {n=G.UIT.R, config={align = "cm"}, nodes={
              {n=G.UIT.O, config={object = DynaText({string = {localize('ph_improve_run')}, colours = {lighten(G.C.GOLD, 0.3)},shadow = true, rotate = true, float = true, bump = true, scale = 0.5, spacing = 1, pop_in = 1.5, maxw = 4.3})}}
            }},
          }},
        }},
      config = {
        align="cm",
        offset = {x=0,y=-15},
        major = G.HUD:get_UIE_by_ID('row_blind'),
        bond = 'Weak'
      }
    }'''

# Bouffalant working with Cerulean Bell
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''forced_card.ability.forced_selection = true'''
position = "after"
payload = '''forced_card.ability.bouffalant_forced_selection = true'''
match_indent = true

[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''v.ability.forced_selection = nil'''
position = "after"
payload = '''v.ability.bouffalant_forced_selection = nil'''
match_indent = true

## Mega Malamar gaming
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''for k, v in ipairs(G.jokers.cards) do
        if v.facing == 'back' then v:flip() end
    end'''
position = "at"
payload = '''if #find_joker("mega_malamar") == 0 then
  for k, v in ipairs(G.jokers.cards) do
        if v.facing == 'back' then v:flip() end
    end
  end'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "card.created_on_pause = nil"
position = "after"
match_indent = true
payload = '''if #find_joker("mega_malamar") > 0 and not (card.facing == 'back') then
      card.facing = 'back'
      card.sprite_facing = 'back'
    end'''

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if not skip_materialize then card:start_materialize(colours, silent) end"
position = "after"
match_indent = true
payload = '''if #find_joker("mega_malamar") > 0 and not (card.facing == 'back') then
      card.facing = 'back'
      card.sprite_facing = 'back'
    end'''

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''end
    return card'''
position = "at"
match_indent = true
payload = '''end
    if #find_joker("mega_malamar") > 0 and not (card.facing == 'back') then
      card.facing = 'back'
      card.sprite_facing = 'back'
    end
    return card'''

[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = '''function CardArea:emplace(card, location, stay_flipped)'''
position = "after"
match_indent = true
payload = '''    stay_flipped = stay_flipped or (self ~= G.hand and #find_joker("mega_malamar") > 0)'''

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''function create_shop_card_ui(card, type, area)'''
position = "after"
match_indent = true
payload = ''' if #find_joker("mega_malamar") > 0 and not (card.facing == 'back') then
      card.facing = 'back'
      card.sprite_facing = 'back'
    end'''


# Preventing pokerus from acting weirdly when evolving
[[patches]]
[patches.pattern]
target = '=[SMODS Pokermon "functions/pokefunctions.lua"]'
pattern = '''if card.ability.extra.energy_count or card.ability.extra.c_energy_count then'''
position = "at"
match_indent = true
payload = '''if (card.ability.extra.energy_count or card.ability.extra.c_energy_count) and not card.ability.maelmc_pokerus then'''

# Wonder Trade
[[patches]]
[patches.pattern]
target = '=[SMODS Multiplayer "networking/action_handlers.lua"]'
pattern = '''local function enemyLocation(options)'''
position = "before"
match_indent = true
payload = '''local function action_wonder_trade(msg)
  local parsedMsg = MP.UTILS.string_to_table(msg, "/", ";")
  local key = parsedMsg["key"]
  local edition = parsedMsg["edition"]
  local energies = parsedMsg["energies"]
  local extra = parsedMsg["extra"]

	local compat = {}
	for i = 1, #G.jokers.cards do
		if G.jokers.cards[i].config.center.key ~= "j_maelmc_wonder_trade" then
			table.insert(compat,G.jokers.cards[i])
		end
	end
	local tosend_j = pseudorandom_element(compat,"wonder_trade")
	if tosend_j then
    local tosend = tosend_j.config.center.key
    for i = 1, #G.jokers.cards do
			if G.jokers.cards[i].config.center.key == tosend then
				G.E_MANAGER:add_event(Event({
          func = function()
            G.jokers.cards[i]:remove()
            return true
          end
        }))
				break
			end
		end
    
		wonder_trade_joker_creation(key,extra,energies,edition)

    local msg_2 = wonder_trade_string_maker(tosend_j)
		MP.ACTIONS.wonder_trade_response(msg_2,key)
	end
end

local function action_wonder_trade_response(msg)
  local parsedMsg = MP.UTILS.string_to_table(msg, "/", ";")
  local key = parsedMsg["key"]
  local edition = parsedMsg["edition"]
  local energies = parsedMsg["energies"]
  local extra = parsedMsg["extra"]
  local sent = parsedMsg["sent"]

  for i = 1, #G.jokers.cards do
    if G.jokers.cards[i].config.center.key == sent then
      G.E_MANAGER:add_event(Event({
        func = function()
          G.jokers.cards[i]:remove()
          return true
        end
      }))
      break
    end
  end
  wonder_trade_joker_creation(key,extra,energies,edition)
end
'''

[[patches]]
[patches.pattern]
target = '=[SMODS Multiplayer "networking/action_handlers.lua"]'
pattern = '''function MP.ACTIONS.fail_timer()'''
position = "before"
match_indent = true
payload = '''function MP.ACTIONS.wonder_trade(msg)
  Client.send("action:magnetResponse,key:reqType;WTREQUEST/"..msg)
end

function MP.ACTIONS.wonder_trade_response(msg,sent)
  Client.send("action:magnetResponse,key:reqType;WTANSWER/"..msg.."/sent;"..sent)
end'''

[[patches]]
[patches.pattern]
target = '=[SMODS Multiplayer "networking/action_handlers.lua"]'
pattern = '''elseif parsedAction.action == "version" then'''
position = "before"
match_indent = true
payload = '''elseif parsedAction.action == "magnetResponse" and string.find(parsedAction.key,"WTREQUEST") then
	action_wonder_trade(parsedAction.key)
elseif parsedAction.action == "magnetResponse" and string.find(parsedAction.key,"WTANSWER") then
	action_wonder_trade_response(parsedAction.key)'''

# Wonder Trade with NanoMultiplayer
[[patches]]
[patches.pattern]
target = '=[SMODS NanoMultiplayer "networking/action_handlers.lua"]'
pattern = '''local function enemyLocation(options)'''
position = "before"
match_indent = true
payload = '''local function action_wonder_trade(msg)
  local parsedMsg = MP.UTILS.string_to_table(msg, "/", ";")
  local key = parsedMsg["key"]
  local edition = parsedMsg["edition"]
  local energies = parsedMsg["energies"]
  local extra = parsedMsg["extra"]

	local compat = {}
	for i = 1, #G.jokers.cards do
		if G.jokers.cards[i].config.center.key ~= "j_maelmc_wonder_trade" then
			table.insert(compat,G.jokers.cards[i])
		end
	end
	local tosend_j = pseudorandom_element(compat,"wonder_trade")
	if tosend_j then
    local tosend = tosend_j.config.center.key
    for i = 1, #G.jokers.cards do
			if G.jokers.cards[i].config.center.key == tosend then
				G.E_MANAGER:add_event(Event({
          func = function()
            G.jokers.cards[i]:remove()
            return true
          end
        }))
				break
			end
		end
    
		wonder_trade_joker_creation(key,extra,energies,edition)

    local msg_2 = wonder_trade_string_maker(tosend_j)
		MP.ACTIONS.wonder_trade_response(msg_2,key)
	end
end

local function action_wonder_trade_response(msg)
  local parsedMsg = MP.UTILS.string_to_table(msg, "/", ";")
  local key = parsedMsg["key"]
  local edition = parsedMsg["edition"]
  local energies = parsedMsg["energies"]
  local extra = parsedMsg["extra"]
  local sent = parsedMsg["sent"]

  for i = 1, #G.jokers.cards do
    if G.jokers.cards[i].config.center.key == sent then
      G.E_MANAGER:add_event(Event({
        func = function()
          G.jokers.cards[i]:remove()
          return true
        end
      }))
      break
    end
  end
  wonder_trade_joker_creation(key,extra,energies,edition)
end
'''

[[patches]]
[patches.pattern]
target = '=[SMODS NanoMultiplayer "networking/action_handlers.lua"]'
pattern = '''function MP.ACTIONS.fail_timer()'''
position = "before"
match_indent = true
payload = '''function MP.ACTIONS.wonder_trade(msg)
  Client.send("action:magnetResponse,key:reqType;WTREQUEST/"..msg)
end

function MP.ACTIONS.wonder_trade_response(msg,sent)
  Client.send("action:magnetResponse,key:reqType;WTANSWER/"..msg.."/sent;"..sent)
end'''

[[patches]]
[patches.pattern]
target = '=[SMODS NanoMultiplayer "networking/action_handlers.lua"]'
pattern = '''elseif parsedAction.action == "version" then'''
position = "before"
match_indent = true
payload = '''elseif parsedAction.action == "magnetResponse" and string.find(parsedAction.key,"WTREQUEST") then
	action_wonder_trade(parsedAction.key)
elseif parsedAction.action == "magnetResponse" and string.find(parsedAction.key,"WTANSWER") then
	action_wonder_trade_response(parsedAction.key)'''